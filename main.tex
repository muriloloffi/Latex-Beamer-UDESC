\documentclass[15pt]{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{bibentry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}

\title[Uma Certificação em Coq do Algoritmo W Monádico]{Uma Certificação em Coq do\\ Algoritmo W Monádico}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Agosto de 2019}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Sumário}
  \begin{itemize}
    \item Introdução
    \item Fundamentos
    \item Certificação da Unificação 
    \item Certificação do Algoritmo W
  \end{itemize}

\end{frame}
\section{Introdução}
\begin{frame}[fragile]
\frametitle{Introdução - Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos são relações que ditam quais expressões podem ser associadas a quais tipos.
    \item Nas linguagens de programação, classificavam os dados para serem tratados corretamente pelo processador;
    \item Passaram a ser utilizados como uma técnica para identificar falhas na consistência de programas.
    \item Tipagem estática e dinâmica:
      \begin{itemize}
        \item Estática: atribuições de tipo não mudam em \textit{run time}; uma forma de verificação automática. 
        \item Dinâmica: atribuições de tipo \textbf{podem mudar} em \textit{run time}; mais permissível; mais permissível a erros. 
      \end{itemize}
      \begin{minted}{python}
      [1, 'a', objeto, [2]]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Inferência de Tipos e Polimorfismo}
\begin{itemize}
    \item A \textbf{inferência de tipos} é o processo de encontrar a assinatura de tipo de um programa.
    \item Liberdade ao programador de escolher anotar ou não os tipos das funções.
    \item Polimorfismo é quando uma função pode assumir vários usos com diferentes tipos de dados. Em especial,
      o polimorfismo paramétrico é feito pela quantificação de variáveis de tipos.
      \begin{minted}{haskell}
         reverse :: [a] -> [a]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Algoritmo para Inferência de Tipos}
  \begin{itemize}
  \item O \textbf{algoritmo W} é um algoritmo para a inferência de tipos no sistema Damas-Milner.\\
        Uma das bases para a inferência em Haskell e OCaml.
  \item \textit{Idealmente} um algoritmo de inferência deve \textit{representar} o que o seu sistema de tipos define. 
  \item Formalmente isso é \textit{Soundness} e \textit{Completeness}.
  \item \textit{Essas propriedades são diretamente refletidas nas implementações?}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Provas mecanizadas}
  \begin{itemize}
  \item O uso de assistentes de provas na pesquisa de linguagens de programação.
  \item Aproximam formalização e implementação. 
  \item Reduzem o trabalho da verificação da prova.
  \item \textit{PoplMark Challenge} e \textit{Principles of Programming Languages} (POPL)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - O que é este trabalho?}
  \pause
  \begin{center}
  \begin{Large}
    Uma Certificação em Coq do\\ Algoritmo W Monádico
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
  \item Uma completa certificação de uma implementação monádica do \textbf{algoritmo W} no
        assistentes de provas Coq.
  \item Certificação do algoritmo de unificação.
  \item Uso da \textit{Hoare State Monad} (HSM) para certificar o código monádico.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Objetivos específicos}
\begin{itemize}
  \item Uma implementação certificada do \textbf{algoritmo de unificação}: consistência, completude e terminação.
  \item Modificar a \textit{Hoare State Monad} para lidar com o efeito de exceção necessário no
        algoritmo W e avaliar as qualidades dessa técnica.
  \item Provar a consistência e a completude do algoritmo W monádico.
\end{itemize}
\end{frame}

\section{Fundamentos}

\begin{frame}[fragile]
  \frametitle{Fundamentos - Damas-Milner e algoritmo W}
  \begin{itemize}
  \item Damas-Milner: polimorfismo via \textit{let}: forma restrita de polimorfismo.
  \item O algoritmo W é consistente e completo em relação as regras de Damas-Milner.
  \item Consistência (\textit{Soundness}): O que o algoritmo W infere pode ser demostrado pelas regras de Damas-Milner.
  \item Completude (\textit{Completeness}): Se o sistema Damas-Nilner mostra que
    $e$ tem o tipo $\tau$, então o algoritmo infere para $e$ o tipo
    $\tau'$, de maneira que $\tau = \mathbb{R}(\tau')$ para alguma
    substituição $\mathbb{R}$. 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fundamentos - Trabalhos relacionados}
\begin{small}
\begin{itemize}
 \item \cite{du:99} forneceram provas em Coq de consistência e completude do algoritmo W. As propriedades
  da unificação foram tomadas como axiomas
        e \textit{binding} de variáveis é resolvido com \textit{de Bruijn indices}.
  \item \cite{na:99} também apresentaram provas de consistência e completude do algoritmo W, mas em Isabelle/HOL.
        As propriedades da unificação também foram assumidas como axiomas e \textit{de Bruijn indices} também foi utilizado.
  \item \cite{ko:09a} relataram um resultado parcial na certificação em Coq da extensão polimórfica do algoritmo
        de Wand.
  \item \cite{ta:15} verificaram a inferência de tipos de CakeML, uma linguagem baseada em SML (Standard ML) cujo compilador
         tem um \textit{backend} completamente verificado \cite{ki:19}.  As provas de consistência e completude da inferência de tipos
         foram feitas no assistente de provas HOL4.
\end{itemize}
\end{small}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Fundamentos - \textit{Hoare State Monad}}
\begin{itemize}
    \item \textit{Hoare State Monad} (HSM): apresentada por \cite{sw:09}\\ Uma variante da usual mônada de estados.
    \item Verificação de programas com efeitos de estado.
    \item Um tipo \mintinline{coq}{HoareState p a q}: : a pré-condição, o tipo do valor de retorno e a pós-condição.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (pre : Pre) (a : Type) (post : Post a) : Type :=
  forall i : {t : st | pre t}, {(x, f) : a * st | post i x f}.

Program Definition ret (a : Type) : forall x,
    @HoareState top a (fun i y f => i = f /\ y = x) := fun x s => (x, s).

Program Definition bind : forall a b P1 P2 Q1 Q2,
    (@HoareState P1 a Q1) -> (forall (x : a), @HoareState (P2 x) b (Q2 x)) ->
    @HoareState (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2)
             b
             (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
              fun a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                              | (x, s2) => c2 x s2
                              end.
\end{minted}
\caption{A Mônada de Estado de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Fundamentos - \textit{Hoare Exception-State Monad}}
\begin{itemize}
    \item O algoritmo W tem dois tipos de efeitos: estado e exceção.
    \item \textit{Hoare Exception-State Monad} (HESM):\\ embute-se o tipo \textit{sum} na definição de HoareState.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (B:Prop) (pre:Pre) (a:Type) (post:Post a) : Type :=
  forall i : {t : st | pre t},
    {e : sum (prod a st) B | match e with
                             | inl (x, f) => post (proj1_sig i) x f
                             | inr _ => True
                             end}.

Program Definition bind : forall a b P1 P2 Q1 Q2 B,
  (@HoareState B P1 a Q1) -> (forall (x:a), @HoareState B (P2 x) b (Q2 x)) ->
  @HoareState B (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2) b
                (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
    fun B a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                                      | inl (x, s2) => c2 x s2
                                      | inr R => _
                                      end.
\end{minted}
\caption{A Mônada de Estado-Exceção de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\section{Certificação do algoritmo W}

\begin{frame}
\frametitle{Certificação do algoritmo W - Unificação I}
\begin{itemize}
    \item O algoritmo de unificação \cite{ro:65} é parte fundamental do algoritmo W.
    \item Modifica-se a certificação da unificação realizada por \cite{ri:16}:
      \begin{itemize}
        \item A operação da substituição é de reformulada para ser não-incremental.
        \item O algoritmo é reescrito para unificar somente dois tipos, ao invés de uma lista de tipos. 
      \end{itemize}
    \item A unificação não é recursão estrutural. A prova de terminação é feita por uma relação bem-fundada sobre uma ordenação lexicográfica.
    \item Essas modificações resultaram em algumas alterações não triviais na prova de terminação.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Unificação II}
\begin{itemize}
    \item Os tipos (monomórficos) são definidos em Coq como tipos indutivos, onde os identificadores são números naturais.
    \item A substituição de tipos é definida em Coq como uma lista de duplas de identificadores de tipo e tipos. \\
      Acompanhado de uma operação de aplicação da substituição.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq I}
\begin{itemize}
    \item O trabalho de \cite{du:99} é a principal referência desta formalização. 
    \item Termos e tipos da linguagem de Damas-Milner são definidos em Coq como tipos indutivos.
    \item A linguagem dos tipos é divida em duas:
      \begin{itemize}
        \item Tipos monomórficos.
        \item Tipos polimórficos: possuem um construtor a mais para representar variáveis quantificadas.
      \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Damas-Milner em Coq II}
\begin{itemize}
    \item Contextos são representados como listas de duplas de identificadores e tipos polimórficos.
    \item As regras de tipagem do sistema Damas-Milner são utilizadas na versão \textit{syntax-directed}, pelo o tipo indutivo \mintinline{coq}{has_type}.
    \item Essas modificações resultaram em algumas alterações não triviais na prova de terminação. \\
      \begin{itemize}
        \item Arvores de provas tem um único formato para cada termo lambda
        \item Quantificação e instanciação estão embutidas, respectivamente, nas regras para variáveis e \textit{lets}.
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Instanciação de tipos}
\begin{itemize}
    \item Tipos polimórficos são instanciados para tipos monomórficos por meio de uma operação de substituição
  especial chamada.
    \item Definiu-se uma forma de substituição: \mintinline{coq}{inst_subst} é apenas uma lista de tipos monomórficos,
  ao invés de uma lista de associatividade.
    \item O número $n$ na variável quantificada associada com o tipo encontrado na $n$-ésima posição em \mintinline{coq}{inst_subst}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Certificação do algoritmo W - Generalização de tipos}
  \begin{block}{A problemática da generalização}
    \begin{itemize}
      \item $\alpha$ e $\beta$ são duas variáveis de tipo sintaticamente distintas.
      \item Não ocorrem livres no contexto considerado.
      \item Os tipos $\alpha \rightarrow \alpha$ and $\beta \rightarrow \beta$ são quantificados, respectivamente, para
        $\forall \alpha, \alpha \rightarrow \alpha$ e $\forall \beta, \beta \rightarrow \beta$.
      \item Sintaticamente diferentes, mas representam exatamente o mesmo conjunto de tipos.
    \end{itemize}
   \end{block} 
   \pause
   \begin{itemize}
   \item \textit{Binding} de variáveis costuma dificultar provas. \\
     Utiliza-se \textit{de Bruijn indices} para lidar com as variáveis quantificadas e evitar lidar com equivalência $\alpha$.
   \item A função de \mintinline{coq}{gen_ty} quantifica as variáveis de tipo são quantificados linearmente: se
     \mintinline{coq}{var n} é a $m$-ésima variável de tipo, então essa é convertida em \mintinline{coq}{sc_gen m}.
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - A algoritmo W monádico}
   \begin{itemize}
     \item O algoritmo W foi implementado de forma monádica com a HESM.
     \item A certificação é garantida pela assinatura com tipos dependentes:
   \end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\begin{minted}[escapeinside=!!,mathescape=true, fontsize=\footnotesize]{coq}
Program Fixpoint W (e:term) (G:ctx) {struct e} :
  Infer (fun i => new_tv_ctx G i) (ty * substitution)
    (fun i x f => i <= f /\ new_tv_subst (snd x) f /\ new_tv_ty (fst x) f /\
    new_tv_ctx (apply_subst_ctx (snd x) G) f /\
    has_type (apply_subst_ctx ((snd x)) G) e (fst x) /\
    completeness e G (fst x) ((snd x)) i) :=
\end{minted}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Estabilidade da substituição}
\begin{itemize}
  \item O lema da estabilidade da substituição é uma propriedade clássica em sistemas de tipos e é fundamental na prova da consistência.
  \item Se é verdade que \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}, então para qualquer substituição $\mathbb{S}$ tem-se \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\mathbb{S} \Gamma \vdash $ *e* $:\mathbb{S} \tau$*}.
  \item Casos monomórficos são fáceis. Além do caso polimórfico do \mintinline{coq}{let_ht} há também o caso do \mintinline{coq}{fix_ht}. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Fundamentos teóricos para formalização do MMo.
  \item Assistentes de provas Coq.
  \item Como o MMo funciona.
  \item Formalização do MMo parcial.
  \item Principais dificuldades encontradas.
  \item Alternativas para a prova de terminação.
\end{itemize}
\end{frame}

\begin{frame}[t, allowframebreaks, noframenumbering]
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{references}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
