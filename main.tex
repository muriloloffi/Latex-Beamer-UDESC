\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage[portuges]{babel}


\title[Sistemas de Tipos]{Sistemas de Tipos}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{10 de Julho de 2019}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}[fragile]
\frametitle{Plano de Aula - Sistema de Tipos}
\begin{block}{Objetivos}
  Explicar o que são e para que servem sistemas de tipos na
  Ciência da Computação.
\end{block}
\begin{block}{Conteúdos}
  \begin{itemize}
    \item Breve visão histórica.
    \item Usos informais em linguagens de programação.
    \item Sistemas de tipos formais em linguagens de programação.
    \item Outras aplicações de sistemas de tipos.
  \end{itemize}
\end{block}
\begin{block}{Método}
  Exposição do conteúdo com exemplos, questionamentos e exercícios.
\end{block}
\end{frame}

\section{Breve visão histórica}
\begin{frame}[fragile]
  \frametitle{Visão histórica - Russel}
  \begin{block}{Teoria dos Tipos}
    \begin{columns}
      \begin{column}{0.5\textwidth}
        \begin{itemize}
        \item Bertrand Russell
        \item Teorias de Tipos são uma resposta
          ao paradoxo de Russel presente na \textit{naive set theory}.
        \item Uma teoria alternativa a Teoria dos Conjuntos para uma função
          formal da matemática.
        \end{itemize}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{center}
          \includegraphics[width=0.8\textwidth]{russel.jpg}
        \end{center}
      \end{column}
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Visão histórica - Church}
  \begin{block}{Teoria dos Tipos}
    \begin{columns}
      \begin{column}{0.5\textwidth}
        \begin{itemize}
        \item Alonzo Church
        \item Aplicou a teoria de tipos de Russel no
          modelo de computação chamado Cálculo Lambda, a
          fim de evitar paradoxos e computações sem fim.
        \item Essa junção entre Teoria de Tipos e Cálculo Lambda é o
          fundamento teórico para sistemas de tipos em linguagens de programação.
        \end{itemize}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{center}
          \includegraphics[width=0.8\textwidth]{church.jpg}
        \end{center}
      \end{column}
    \end{columns}
  \end{block}
\end{frame}

\section{Usos informais}
\begin{frame}[fragile]
\frametitle{Questões preliminares}
O que são tipos (em linguagens de programação)?
\pause
\begin{itemize}
  \item Classificações dos dados de um programa: carácter, inteiro, função etc.
\end{itemize}
\pause
Por que (algumas) linguagens de programação utilizam tipos?
\pause
\begin{columns}
  \begin{column}{0.5\textwidth}
\begin{minted}{c}
void foo() {
  int n = 1;
  char m = '2';
  printf("%d\n", n + m);
}
\end{minted}
\end{column}
\begin{column}{0.5\textwidth}
\begin{minted}{c}
void spam() {
  int n;
  scanf("%d", &n);
  printf("%d\n", n);
  return 0;
}
\end{minted}
\end{column}
\end{columns}
\pause
Os tipos fazem parte da construção semântica dos programas.
\end{frame}

\begin{frame}[fragile]
\frametitle{Tipagem estática vs dinâmica}
\begin{itemize}
  \item Na tipagem estática a verificação dos tipos é feita em por análise do código durante a compilação.
  \item Na tipagem dinâmica as verificações dos tipos é feita somente na execução.\\ Se uma parte do código com
    erro (de tipo) não for executada, o erro ficará oculto.
\end{itemize}
\pause
\begin{itemize}
  \item Estática: atribuições de tipo não mudam em \textit{run time}.
  \item Dinâmica: atribuições de tipo \textbf{podem mudar} em \textit{run time}.
\end{itemize}
\pause
Exemplos de linguagens de tipagem estática?\\
\pause
C, C++, Java, Rust, Haskell, OCaml...\\
\pause
Exemplos de linguagens de tipagem dinâmica?\\
\pause
Python, PHP, JavaScript, Lisp, Erlang...
\end{frame}

\begin{frame}[fragile]
\frametitle{Vantagens e desvantagens:  estática e dinâmica}
Estática:
\begin{itemize}
  \item Vantagens: Reduz os possíveis erros em tempo de execução; Possibilita algumas otimizações de código
   pelo compilador; Verificação automática; Útil em códigos grandes.
 \item Desvantagens: Mais uma coisa para aprender sobre a linguagem;
   Requerem que tipos sejam explicitados (não todas as linguagens); Podem limitar o reuso de código.
\end{itemize}

Dinâmica:
\begin{itemize}
  \item Vantagens: Mais permissível; Mais fácil de aprender; geralmente tem mais interatividade (REPL).
  \item Desvantagens: Testes são muito mais importantes; abre espaço para erros inesperados em execução;
    geralmente são menos eficientes. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Tipagem forte e fraca}
Esse é um conceito meio nebuloso! \\
Não é preto ou branco\\
\begin{itemize}
  \item Forte: as regras de tipagem são rígidas; não há cast de tipos implícitos; os casts de tipos fazem sentido.
  \item Fraca: as regras de tipagem são flexíveis; casts automáticos podem ocorrer.
\end{itemize}
\pause
Em Python:
\begin{minted}{python}
"Dia " + str(1) + " de Janeiro" 
\end{minted}
\pause
Em JavaScript:
\begin{minted}{js}
[] + []; // "" 
[] + 1; // "1" 
1 + {}; // "1[object object]" 
{} + [] // 0 
\end{minted}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos são regras que ditam quais expressões podem ser
associadas a quais tipos.
    \item Nas linguagens de programação, classificavam os dados para serem tratados corretamente pelo processador;
    \item passaram a ser utilizados como regras para identificar falhas na consistência
de programas
    \item Tipagem estática e dinâmica:
      \begin{itemize}
        \item Estática: atribuições de tipo não mudam em \textit{run time}; uma forma de verificação automática. 
        \item Dinâmica: atribuições de tipo \textbf{mudam} em \textit{run time}; mais permissível; mais permissível a erros. 
      \end{itemize}
      \begin{minted}{python}
      [1, 'a', objeto, [2]]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Inferência de Tipos e Polimorfismo}
\begin{itemize}
    \item A inferência de tipos é o processo de encontrar a assinatura de tipo mais geral de um programa.
    \item Liberdade ao programador de escolher anotar ou não os tipos das funções.
    \item Polimorfismo é quando uma função pode assumir vários usos com diferentes tipos de dados. Em especial,
      o polimorfismo paramétrico é feito pela quantificação de variáveis de tipos.
      \begin{minted}{haskell}
         len :: [a] -> Int
      \end{minted}
    \item Existem situações onde a inferência de tipos é mais difícil que a verificação. Nesses casos,
      algoritmos podem rejeitar programas bem tipados.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Formalismos de Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos quando definidos formalmente podem garantir importantes propriedades da
    semântica de programas, como o famoso lema de Robin Milner ``Well-typed programs cannot go wrong''.
    \item Damas-Milner: polimorfismo via \textit{let}. Base para diversas linguagens de programação funcional.
    Não permite recursão polimórfica pela regra $fix$.
    \item O primeiro sistema de tipos a permitir recursão polimórfica é o Sistema-F. 
    \item Milner-Mycroft altera a regra de definições recursivas $fix$ para permitir recursões polimórficas.
\end{itemize}
\begin{center}
  \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\tau \vdash$ \mintinline{haskell}{e} $:\tau$}
      \RightLabel{$(fix)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\tau$}
    \end{prooftree}
    \end{minipage}
    \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\sigma \vdash$ \mintinline{haskell}{e} $:\sigma$}
      \RightLabel{$(fix+)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\sigma$}
    \end{prooftree}
    \end{minipage}
\end{center}
\end{frame}
\section{Usos informais}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Fundamentos teóricos para formalização do MMo.
  \item Assistentes de provas Coq.
  \item Como o MMo funciona.
  \item Formalização do MMo parcial.
  \item Principais dificuldades encontradas.
  \item Alternativas para a prova de terminação.
\end{itemize}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
