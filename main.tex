\documentclass{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\title[Uma Certificação em Coq do Algoritmo W Monádico]{Uma Certificação em Coq do\\ Algoritmo W Monádico}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Agosto de 2019}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Sumário}
  \begin{itemize}
    \item Introdução.
    \item Fundamentos.
    \item Certificação da Unificação. 
    \item Certificação do Algoritmo W. 
  \end{itemize}

\end{frame}
\section{Introdução}
\begin{frame}[fragile]
\frametitle{Introdução - Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos são relações que ditam quais expressões podem ser associadas a quais tipos.
    \item Nas linguagens de programação, classificavam os dados para serem tratados corretamente pelo processador;
    \item Passaram a ser utilizados como uma técnica para identificar falhas na consistência de programas
    \item Tipagem estática e dinâmica:
      \begin{itemize}
        \item Estática: atribuições de tipo não mudam em \textit{run time}; uma forma de verificação automática. 
        \item Dinâmica: atribuições de tipo \textbf{podem mudar} em \textit{run time}; mais permissível; mais permissível a erros. 
      \end{itemize}
      \begin{minted}{python}
      [1, 'a', objeto, [2]]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Inferência de Tipos e Polimorfismo}
\begin{itemize}
    \item A \textbf{inferência de tipos} é o processo de encontrar a assinatura de tipo de um programa.
    \item Liberdade ao programador de escolher anotar ou não os tipos das funções.
    \item Polimorfismo é quando uma função pode assumir vários usos com diferentes tipos de dados. Em especial,
      o polimorfismo paramétrico é feito pela quantificação de variáveis de tipos.
      \begin{minted}{haskell}
         reverse :: [a] -> [a]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Algoritmo para Inferência de Tipos}
  \begin{itemize}
  \item O \textbf{algoritmo W} é um algoritmo para a inferência de tipos no sistema Damas-Milner.\\
        Uma das bases para a inferência em Haskell e OCaml.
  \item \textit{Idealmente} um algoritmo de inferência deve \textit{representar} o que o seu sistema de tipos define. 
  \item Formalmente isso é \textit{Soundness} e \textit{Completeness}.
  \item \textit{Essas propriedades são diretamente refletidas nas implementações?}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Provas mecanizadas}
  \begin{itemize}
  \item O uso de assistentes de provas na pesquisa de linguagens de programação.
  \item Aproximam formalização e implementação. 
  \item Reduzem o trabalho da verificação da prova.
  \item \textit{PoplMark Challenge} e \textit{Principles of Programming Languages} (POPL)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - O que é este trabalho?}
  \pause
  \begin{center}
  \begin{Large}
    Uma Certificação em Coq do\\ Algoritmo W Monádico
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
  \item Uma completa certificação de uma implementação monádica do \textbf{algoritmo W} no
        assistentes de provas Coq.
  \item Certificação do algoritmo de unificação.
  \item Uso da \textit{Hoare State Monad} (HSM) para certificar o código monádico.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Objetivos específicos}
\begin{itemize}
  \item Uma implementação certificada do \textbf{algoritmo de unificação}: consistência, completude e terminação.
  \item Modificar a \textit{Hoare State Monad} para lidar com o efeito de exceção necessário no
        algoritmo W e avaliar as qualidades dessa técnica.
  \item Provar a consistência e a completude do algoritmo W monádico.
\end{itemize}
\end{frame}
\section{Fundamentos}

\begin{frame}
\frametitle{Fundamentos - Formalismos de Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos quando definidos formalmente podem garantir importantes propriedades da
    semântica de programas, como o famoso lema de Robin Milner ``Well-typed programs cannot go wrong''.
    \item Damas-Milner: polimorfismo via \textit{let}. Base para diversas linguagens de programação funcional.
    Não permite recursão polimórfica pela regra $fix$.
    \item O primeiro sistema de tipos a permitir recursão polimórfica é o Sistema-F. 
    \item Milner-Mycroft altera a regra de definições recursivas $fix$ para permitir recursões polimórficas.
\end{itemize}
\begin{center}
  \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\tau \vdash$ \mintinline{haskell}{e} $:\tau$}
      \RightLabel{$(fix)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\tau$}
    \end{prooftree}
    \end{minipage}
    \begin{minipage}{.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, $\mintinline{haskell}{x} $:\sigma \vdash$ \mintinline{haskell}{e} $:\sigma$}
      \RightLabel{$(fix+)$}
      \UnaryInfC{$\Gamma \vdash$ \mintinline{haskell}{fix x.e} $:\sigma$}
    \end{prooftree}
    \end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fundamentos - Inferência no Milner-Mycroft}
\begin{itemize}
    \item A inferência no sistema Milner-Mycroft é equivalente ao problema da semi-unificação.
    \item A semi-unificação é uma generalização da unificação.
    \item A semi-unificação é indecidível.
      \begin{itemize}
        \item Casos decidíveis: apenas uma igualdade, qualquer aridade e no máximo uma variável livre, duas variáveis e semi-unificação acíclica.
      \end{itemize}
    \item No caso geral não há como decidir a tipabilidade (\textit{typability}) de um termo no sistema Milner-Mycroft.
    \item \textit{Big type} vs \textit{small type}.
    \item \textit{Small types} no sistema Milner-Mycroft é decidível em tempo polinomial.
    \item Buscou-se alternativas para contornar a dificuldade deste problema.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fundamentos - Propostas de Recursão Polimórfica}
\begin{itemize}
    \item Somente existem semi-algoritmos e algoritmos totais, mas incompletos pois rejeitam alguns programas bem tipados.
    \item O semi-algoritmo para resolver a semi-unificação apresentado em (HENGLEIN, 1993) foi utilizado na construção do semi-algoritmo W+ em (EMMS; LEIL, 1999).
      \begin{itemize}
    \item Damas-Milner tem pior caso exponencial. Não acontece em situações práticas. Prática vs teoria no Milner-Mycroft.
      \end{itemize}
    \item Diversas propostas para recursão polimórfica foram apresentadas na literatura com o uso
      de \textit{intersection types}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Assistentes de provas}
\begin{itemize}
    \item São programas para o desenvolvimento de provas
          formais.
    \item O núcleo é um verificador, que verifica a consistência lógica da prova.
    \item Os principais apelos são:
    \begin{itemize}
    \item a verificação mecânica é rápida e evita as falhas humanas;
    \item interatividade, permite visualizar informações sobre os estados da prova;
    \item comandos para busca de teoremas e lemas para o progresso da
      prova;
    \item automatização de provas com métodos não-deterministas;
    \item potencialização da capacidade humana de realizar provas;
    \item extração de programas verificados.
    \end{itemize}

      Assistentes de provas permitem provar coisas que não seriam realizáveis somente com papel e caneta!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Por que Coq?}
\begin{itemize}
    \item Existem dezenas: Automath, Agda, Twelf, ACL2, PVS, Minlog, Isabelle e Coq...
    \item O núcleo do Coq é o \textit{Calculus of Inductive Constructions} (CIC). Extensão do \textit{Calculus of Constructions} (CoC).
    \item CoC é um Cálculo Lambda polimórfico de ordem superior e com tipos dependentes.
    \item \textbf{Justificativa}:
      \begin{enumerate}
        \item Frequente uso de Coq para formalizar aspectos de linguagens de programação. CoqPL. 
        \item Projetos relevantes em Coq: CompCert é uma compilador de C; Simplicity é uma
          linguagem de programação para \textit{blockchains}; Vellvm é uma
          formalização da LLVM em Coq.
        \item Materiais didáticos disponíveis!
      \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Terminação em Coq}
\begin{itemize}
    \item Coq é uma linguagem de programação funcional total.
    \item A garantia de terminação do Coq é uma conservadora verificação sintática: recursão primitiva.
    \item Coq conta com algumas maneiras de estender o conjunto de programas que podem ser implementados:
    \begin{enumerate}
    \item Recursão bem-fundada (\textit{Well-Founded Recursion}) por meio
      de uma relação bem-fundada (\textit{Well-Founded Relation}). Uma relação bem-fundada.
    \item Recursão limitada (\textit{Bounded Recursion}) através
    de um argumento, que representa o número
    de chamadas recursivas. Suficiente para que a computação finalize com o resultado
    correto.
    \item Recursão por iteração (\textit{Recursion by Iteration}). Similar a recursão limitada. Definição de
    um funcional, que tem como um dos argumentos a
    função \mintinline{coq}{f} que deseja-se implementar. 
    \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Terminação em Coq}
    \begin{enumerate}
      \setcounter{enumi}{3}
    \item Recursão sobre um predicado (\textit{Recursion on an Ad Hoc
        Predicate Section}). Representa o domínio da função. Recursão estrutural sobre
    provas do princípio indutivo deste predicado.
    \item Recursão por mônada inspirada em Teoria de Domínios. Combinadores de ordem superior representam funções
    que não terminam. Uma obrigação de prova é a continuidade da
    computação na mônada.
    \item Recursão geral baseada numa mônada de um tipo co-indutivo.
    É similar ao anterior, mas utiliza os tipos co-indutivos para representar
    a noção de não terminação, com a vantagem de não ter obrigações de provas.
    \item Linguagem embutida: formalizar completamente uma linguagem
    de programação.
    \end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Vantagens Terminação em Coq}
    \begin{itemize}
    \item Somente as quatro primeiras técnicas permitem utilizar o mecanismo de avaliação interno do Coq.
    \item As técnicas 2 e 3 necessitam conhecer uma função capaz de computar o número de chamadas recursivas suficientes para uma dada entrada.
    \item A principal vantagem das últimas três técnicas é a possibilidade de implementar qualquer função recursiva e evitam provas.
    \item No aspecto da extração, a técnica mais eficiente é a primeira, pois as demais podem carregar (na extração) alguns lixos como os argumentos adicionais.
    \end{itemize}
\end{frame}

\section{MMo}

\begin{frame}
\frametitle{MMo - Diferenças básicas}
O MMo funciona de maneira \textit{botton-up} assim como o algoritmo
\textit{W}, ou seja, primeiro inferem-se os termos mais internos da expressão para seguir inferindo os mais externos.
\begin{enumerate}
\item As variáveis com sequência de índices. Detecção de dependências circulares em substituições.
\item Um contexto $\Gamma$ é um conjunto de triplas (\textit{variável},
  $Kind\_def$, \textit{scheme}). Não há condição de
    consistência. \textit{Typing context}.
\item o MMo retorna uma
  dupla com o tipo simples inferido $\tau$ e um contexto $\Gamma$.
\item Para cada definição num \textit{BindGroup} infere-se o respectivo
  conjunto com os pares de identificadores e
  os seus respectivos tipos inferidos e requeridos (dado pelo símbolo $\Sigma$).
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{MMo - Inferência de grupo de definições}
\begin{enumerate}
  \item Computar o conjunto $\Sigma$ com todos os tipos inferidos e requeridos do grupo.
  \item Gera-se a partir de $\Sigma$ um conjunto $\Omega$ de pares tipos inferidos (instâncias) e requeridos 
        $(\tau', \tau)$ que precisam ser unificados.
        \begin{itemize}
          \item o tipo de cada suposição \mintinline[escapeinside=**,mathescape=true]{haskell}{x:*$\tau$*} em
            cada um dos $\Gamma$ em $\Sigma$ precisa ser unificado com uma instância do seu
            respectivo tipo inferido $\tau'$ para \mintinline[escapeinside=**,mathescape=true]{haskell}{x}.
          \item A função \mintinline{haskell}{supInst} troca cada variável de tipo $\alpha^{s}$ de $\tau'$ por uma nova instância $\alpha^{i::s}$.
        \end{itemize}
  \item Verificar a existência de dependências circulares na substituição $\mathbb{S}$ gerada pela unificação de $\Omega$.
  \item Caso exista dependência circular em $\mathbb{S}$, então o MMo termina com erro. Caso contrário, então aplica-se a
         $\mathbb{S}$ em $\Sigma$. Se $\mathbb{S}$ for efetiva, então volta-se para segunda etapa. Se não, para.
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{MMo - Dependências circulares}
\begin{itemize}
  \item Uma dependência circular ocorre quando uma substituição troca uma variável de tipo $\alpha^s$ por um tipo $\tau$, o qual ocorre uma variável de tipo $\alpha^{s'}$ tal que $s$ seja uma subsequência de $s'$. Ex: \mintinline[escapeinside=**,mathescape=true]{haskell}{[a*$^{1, 0} \rightarrow$* b/a*$^0$*]}.
  \item A relação de ser subsequência pode ser indireta, portanto é necessário fazer uma verificação transitiva na substituição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{MMo - Exemplo inferência de grupo}
\begin{minted}{haskell}
  data Seq a = Nil | Cons a (Seq (a,a)).
\end{minted}
\begin{minted}{haskell}
  len :: Seq a -> Int
  len Nil = 0
  len (Cons x s) = 1 + 2 * (len s)
\end{minted}

$\Sigma$:
\begin{minted}[escapeinside=**,mathescape=true]{haskell} 
 *$\{$*(Nil,(Seq a, *$\emptyset$*)),
 (Cons,(b *$\rightarrow$* Seq (b, b) *$\rightarrow$* Seq b, *$\emptyset$*)),
 (len, (Seq c *$\rightarrow$* Int,
     *$\{$*(+):Int *$\rightarrow$* Int *$\rightarrow$* Int, len:Seq(c, c) *$\rightarrow$* Int*$\}$*))*$\}$*
\end{minted}

$\Omega$:
\begin{minted}[escapeinside=**,mathescape=true]{haskell}
  *$\{$*(Seq c*$^0$**$\rightarrow$* Int, Seq(c, c) *$\rightarrow$* Int)*$\}$*
\end{minted}

$\mathbb{S}$: \mintinline[escapeinside=**,mathescape=true]{haskell}{[(c, c)/c*$^0$*]}

Não tem dependência circular e não modifica os tipos de
$\Sigma$ (ignorando renomeações de
variáveis)
\end{frame}

\section{Formalização em Coq}

\begin{frame}[fragile]
\frametitle{Formalização em Coq - Detalhes da formalização}
\begin{itemize}
  \item Formalização parcial e simplificada (sem grupos).
  \item Trabalho similar para o algoritmo \textit{W} por (DUBOIS; MÉNISSIER-MORAIN, 1999).
  \item Uso da formalização da unificação feita por (RIBEIRO; CAMARÃO, 2016).
  \item Termos, tipos, \textit{schemes} formalizados como tipos indutivos.
  \item Para garantir que dois tipos generalizados sejam sintaticamente iguais, a respeito
    da equivalência $\alpha$, utiliza-se a notação \textit{De Bruijn} nos \textit{schemes}.
  \item Uso de mônadas de estados e falhas.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização em Coq - Aspectos da terminação}
\begin{itemize}
  \item Coq é uma linguagem de programação funcional total.
  \item De todas as funções do MMo, a que computa o conjunto $\Sigma$ é a única que não
    é de recursão primitiva.
  \item Até o momento não se conhece alguma relação bem fundada a respeito da efetividade
    da substituição.
  \item Utilizar alguma forma de limite de iteração.
  \item Trabalho similar para o algoritmo \textit{W} por (DUBOIS; MÉNISSIER-MORAIN, 1999).
  \item Uso da formalização da unificação feita por (RIBEIRO; CAMARÃO, 2016).
    \begin{itemize}
    \item Seria necessário descobrir como computar esse número ou, então, associar esse valor às regras de inferência.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização em Coq - Aspectos da consistência}
\begin{itemize}
  \item Uso das regras de Damas-Milner em \textit{syntax-directed} em DUBOIS; MÉNISSIER-MORAIN, 1999).
    \begin{itemize}
      \item Regras da forma \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}.
      \item Regras de especialização $(spec)$ e generalização $(gen)$ são fundidas, respectivamente, com as regras $(var)$ e $(let)$.
    \end{itemize}
  \item Regra $(fix+)$ na forma \textit{syntax-directed}. 
  \item As regras de inferência são representadas em Coq como um tipo (proposição) indutivo.
  \item O tipo indutivo é uma certificação que pode ser diretamente utilizada num tipo dependente no MMo:
\end{itemize}
\begin{minted}{coq}
Definition infer_dep : forall (e : term) (G : ctx),
    Infer ({tau : ty &
     {g : ctx | has_type (apply_subst_ctx s G) e tau}})
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Formalização em Coq - Estabilidade da substituição}
\begin{itemize}
  \item O lema da estabilidade da substituição é uma propriedade clássica em sistemas de tipos e é fundamental na prova da consistência.
  \item Se é verdade que \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}, então para qualquer substituição $\mathbb{S}$ tem-se \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\mathbb{S} \Gamma \vdash $ *e* $:\mathbb{S} \tau$*}.
  \item Casos monomórficos são fáceis. Além do caso polimórfico do \mintinline{coq}{let_ht} há também o caso do \mintinline{coq}{fix_ht}. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Fundamentos teóricos para formalização do MMo.
  \item Assistentes de provas Coq.
  \item Como o MMo funciona.
  \item Formalização do MMo parcial.
  \item Principais dificuldades encontradas.
  \item Alternativas para a prova de terminação.
\end{itemize}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
