\documentclass[15pt]{beamer}

\usepackage{graphicx,hyperref,udesc,url}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{bibentry}
\usepackage{graphicx}
\usepackage{booktabs} 
\usepackage[portuges]{babel}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}

\title[Uma Certificação em Coq do Algoritmo W Monádico]{Uma Certificação em Coq do\\ Algoritmo W Monádico}

\author[Rafael Castro]{
    Rafael Castro\\\medskip
    {\small \url{rafaelcgs10@gmail.com}}}

\date{22 de Agosto de 2019}

    \institute[UDESC]{
        Departamento de Ci\^encia da Computa\c{c}\~ao \\
            Centro de Ci\^encias e Tecnol\'ogicas\\
            Universidade do Estado de Santa Catarina}

\begin{document}

\begin{frame}
\titlepage

\end{frame}

\begin{frame}{Sumário}
  \begin{itemize}
    \item Introdução
    \item Fundamentos
    \item Certificação da Unificação 
    \item Certificação do Algoritmo W
  \end{itemize}

\end{frame}
\section{Introdução}
\begin{frame}[fragile]
\frametitle{Introdução - Sistemas de Tipos}
\begin{itemize}
    \item Sistemas de tipos são relações que ditam quais expressões podem ser associadas a quais tipos.
    \item Nas linguagens de programação, classificavam os dados para serem tratados corretamente pelo processador;
    \item Passaram a ser utilizados como uma técnica para identificar falhas na consistência de programas.
    \item Tipagem estática e dinâmica:
      \begin{itemize}
        \item Estática: atribuições de tipo não mudam em \textit{run time}; uma forma de verificação automática. 
        \item Dinâmica: atribuições de tipo \textbf{podem mudar} em \textit{run time}; mais permissível; mais permissível a erros. 
      \end{itemize}
      \begin{minted}{python}
      [1, 'a', objeto, [2]]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Introdução - Inferência de Tipos e Polimorfismo}
\begin{itemize}
    \item A \textbf{inferência de tipos} é o processo de encontrar a assinatura de tipo de um programa.
    \item Liberdade ao programador de escolher anotar ou não os tipos das funções.
    \item Polimorfismo é quando uma função pode assumir vários usos com diferentes tipos de dados. Em especial,
      o polimorfismo paramétrico é feito pela quantificação de variáveis de tipos.
      \begin{minted}{haskell}
         reverse :: [a] -> [a]
      \end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Algoritmo para Inferência de Tipos}
  \begin{itemize}
  \item O \textbf{algoritmo W} é um algoritmo para a inferência de tipos no sistema Damas-Milner.\\
        Uma das bases para a inferência em Haskell e OCaml.
  \item \textit{Idealmente} um algoritmo de inferência deve \textit{representar} o que o seu sistema de tipos define. 
  \item Formalmente isso é \textit{Soundness} e \textit{Completeness}.
  \item \textit{Essas propriedades são diretamente refletidas nas implementações?}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Provas mecanizadas}
  \begin{itemize}
  \item O uso de assistentes de provas na pesquisa de linguagens de programação.
  \item Aproximam formalização e implementação. 
  \item Reduzem o trabalho da verificação da prova.
  \item \textit{PoplMark Challenge} e \textit{Principles of Programming Languages} (POPL)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - O que é este trabalho?}
  \pause
  \begin{center}
  \begin{Large}
    Uma Certificação em Coq do\\ Algoritmo W Monádico
  \end{Large}
  \end{center}
  \pause
  \begin{itemize}
  \item Uma completa certificação de uma implementação monádica do \textbf{algoritmo W} no
        assistentes de provas Coq.
  \item Certificação do algoritmo de unificação.
  \item Uso da \textit{Hoare State Monad} (HSM) para certificar o código monádico.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introdução - Objetivos específicos}
\begin{itemize}
  \item Uma implementação certificada do \textbf{algoritmo de unificação}: consistência, completude e terminação.
  \item Modificar a \textit{Hoare State Monad} para lidar com o efeito de exceção necessário no
        algoritmo W e avaliar as qualidades dessa técnica.
  \item Provar a consistência e a completude do algoritmo W monádico.
\end{itemize}
\end{frame}

\section{Fundamentos}

\begin{frame}[fragile]
  \frametitle{Fundamentos - Damas-Milner e algoritmo W}
  \begin{itemize}
  \item Damas-Milner: polimorfismo via \textit{let}: forma restrita de polimorfismo.
  \item O algoritmo W é consistente e completo em relação as regras de Damas-Milner.
  \item Consistência (\textit{Soundness}): O que o algoritmo W infere pode ser demostrado pelas regras de Damas-Milner.
  \item Completude (\textit{Completeness}): Se o sistema Damas-Nilner mostra que
    $e$ tem o tipo $\tau$, então o algoritmo infere para $e$ o tipo
    $\tau'$, de maneira que $\tau = \mathbb{R}(\tau')$ para alguma
    substituição $\mathbb{R}$. 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fundamentos - Trabalhos relacionados}
\begin{small}
\begin{itemize}
 \item \cite{du:99} forneceram provas em Coq de consistência e completude do algoritmo W. As propriedades
  da unificação foram tomadas como axiomas
        e \textit{binding} de variáveis é resolvido com \textit{de Bruijn indices}.
  \item \cite{na:99} também apresentaram provas de consistência e completude do algoritmo W, mas em Isabelle/HOL.
        As propriedades da unificação também foram assumidas como axiomas e \textit{de Bruijn indices} também foi utilizado.
  \item \cite{ko:09a} relataram um resultado parcial na certificação em Coq da extensão polimórfica do algoritmo
        de Wand.
  \item \cite{ta:15} verificaram a inferência de tipos de CakeML, uma linguagem baseada em SML (Standard ML) cujo compilador
         tem um \textit{backend} completamente verificado \cite{ki:19}.  As provas de consistência e completude da inferência de tipos
         foram feitas no assistente de provas HOL4.
\end{itemize}
\end{small}
\end{frame}

\begin{frame}
\frametitle{Fundamentos - Assistentes de provas}
\begin{itemize}
    \item São programas para o desenvolvimento de provas
          formais.
    \item O núcleo é um verificador, que verifica a consistência lógica da prova.
    \item Os principais apelos são:
    \begin{itemize}
    \item a verificação mecânica é rápida e evita as falhas humanas;
    \item interatividade, permite visualizar informações sobre os estados da prova;
    \item comandos para busca de teoremas e lemas para o progresso da
      prova;
    \item automatização de provas com métodos não-deterministas;
    \item potencialização da capacidade humana de realizar provas;
    \item extração de programas verificados.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Fundamentos - \textit{Hoare State Monad}}
\begin{itemize}
    \item \textit{Hoare State Monad} (HSM): apresentada por \cite{sw:09}\\ Uma variante da usual mônada de estados.
    \item Verificação de programas com efeitos de estado.
    \item Um tipo \mintinline{coq}{HoareState p a q}: : a pré-condição, o tipo do valor de retorno e a pós-condição.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (pre : Pre) (a : Type) (post : Post a) : Type :=
  forall i : {t : st | pre t}, {(x, f) : a * st | post i x f}.

Program Definition ret (a : Type) : forall x,
    @HoareState top a (fun i y f => i = f /\ y = x) := fun x s => (x, s).

Program Definition bind : forall a b P1 P2 Q1 Q2,
    (@HoareState P1 a Q1) -> (forall (x : a), @HoareState (P2 x) b (Q2 x)) ->
    @HoareState (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2)
             b
             (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
              fun a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                              | (x, s2) => c2 x s2
                              end.
\end{minted}
\caption{A Mônada de Estado de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile, plain]
\frametitle{Fundamentos - \textit{Hoare Exception-State Monad}}
\begin{itemize}
    \item O algoritmo W tem dois tipos de efeitos: estado e exceção.
    \item \textit{Hoare Exception-State Monad} (HESM):\\ embute-se o tipo \textit{sum} na definição de HoareState.
\end{itemize}
  \begin{columns}
    \column{\dimexpr\paperwidth-10pt}
\begin{figure}
\label{fig:hoaremonad1}                               
\begin{minted}[fontsize=\scriptsize]{coq}
Program Definition HoareState (B:Prop) (pre:Pre) (a:Type) (post:Post a) : Type :=
  forall i : {t : st | pre t},
    {e : sum (prod a st) B | match e with
                             | inl (x, f) => post (proj1_sig i) x f
                             | inr _ => True
                             end}.

Program Definition bind : forall a b P1 P2 Q1 Q2 B,
  (@HoareState B P1 a Q1) -> (forall (x:a), @HoareState B (P2 x) b (Q2 x)) ->
  @HoareState B (fun s1 => P1 s1 /\ forall x s2, Q1 s1 x s2 -> P2 x s2) b
                (fun s1 y s3 => exists x, exists s2, Q1 s1 x s2 /\ Q2 x s2 y s3) :=
    fun B a b P1 P2 Q1 Q2 c1 c2 s1 => match c1 s1 as y with
                                      | inl (x, s2) => c2 x s2
                                      | inr R => _
                                      end.
\end{minted}
\caption{A Mônada de Estado-Exceção de Hoare.}
\end{figure}
\end{columns}
\end{frame}

\section{Certificação da unificação}

\begin{frame}
\frametitle{Certificação da unificação - Aspectos da certificação}
\begin{itemize}
    \item São programas para o desenvolvimento de provas
          formais.
    \item O núcleo é um verificador, que verifica a consistência lógica da prova.
    \item Os principais apelos são:
    \begin{itemize}
    \item a verificação mecânica é rápida e evita as falhas humanas;
    \item interatividade, permite visualizar informações sobre os estados da prova;
    \item comandos para busca de teoremas e lemas para o progresso da
      prova;
    \item automatização de provas com métodos não-deterministas;
    \item potencialização da capacidade humana de realizar provas;
    \item extração de programas verificados.
    \end{itemize}
\end{itemize}
\end{frame}

\section{Certificação do algoritmo W}

\begin{frame}[fragile]
\frametitle{Certificação do algoritmo W - Estabilidade da substituição}
\begin{itemize}
  \item O lema da estabilidade da substituição é uma propriedade clássica em sistemas de tipos e é fundamental na prova da consistência.
  \item Se é verdade que \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\Gamma \vdash $ *e* $:\tau$*}, então para qualquer substituição $\mathbb{S}$ tem-se \mintinline[escapeinside=**,mathescape=true]{haskell}{*$\mathbb{S} \Gamma \vdash $ *e* $:\mathbb{S} \tau$*}.
  \item Casos monomórficos são fáceis. Além do caso polimórfico do \mintinline{coq}{let_ht} há também o caso do \mintinline{coq}{fix_ht}. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conclusão}
\begin{itemize}
  \item Fundamentos teóricos para formalização do MMo.
  \item Assistentes de provas Coq.
  \item Como o MMo funciona.
  \item Formalização do MMo parcial.
  \item Principais dificuldades encontradas.
  \item Alternativas para a prova de terminação.
\end{itemize}
\end{frame}

\begin{frame}[t, allowframebreaks, noframenumbering]
\frametitle{References}
\bibliographystyle{apalike}
\bibliography{references}
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
